# Бенчмаркинг обработки массивов и коллекций в Java

Данный проект представляет собой реализацию и сравнительный анализ производительности различных подходов к обработке массивов и коллекций в Java. Основное внимание уделяется четырём операциям: фильтрация чисел, кратных 3 или 5, определение простых чисел, вычисление среднего арифметического и поиск максимальной частоты повторяющихся элементов. Реализации выполнены с использованием различных технологий Java: традиционные массивы, коллекции, параллельные потоки (`parallelStream`), асинхронное программирование (`CompletableFuture`) и фреймворк `ForkJoinPool`. Производительность измеряется с помощью библиотеки JMH (Java Microbenchmark Harness), а результаты визуализируются в виде гистограммы с использованием библиотеки JFreeChart— популярного инструмента для построения графиков. В файле py.java написан код, который читает CSV-файл и создает столбчатую диаграмму (bar chart) для сравнения времени выполнения различных методов.

## Цели проекта

- Реализовать четыре ключевые операции обработки данных с использованием различных подходов.
- Провести микробенчмаркинг для оценки производительности каждого подхода.
- Визуализировать результаты в виде гистограммы для наглядного сравнения времени выполнения.
- Сравнить эффективность различных технологий Java для обработки данных в зависимости от типа задачи.

## Структура проекта

Проект организован в пакете `top.Home_Work` и включает следующие классы:

1. **ArrayTest.java**  
   Реализует обработку массивов типа `int[]` с использованием традиционных циклов `for`.

   - `array3or5`: Фильтрует элементы массива, кратные 3 или 5, возвращая новый массив с отфильтрованными значениями. Использует метод `CommonMethods.isDivisibleBy3Or5`.
   - `arrayPrime`: Фильтрует простые числа, используя метод `CommonMethods.isPrime`.
   - `arrayAverage`: Вычисляет среднее арифметическое элементов массива.
   - `arraySame`: Находит максимальную частоту повторения одного и того же элемента, сортируя массив и подсчитывая последовательные совпадения.  
     Все методы используют `Arrays.copyOf` для создания результирующего массива точного размера.

2. **CollectionTest.java**  
   Реализует обработку коллекций типа `List<Integer>` с использованием методов коллекций.

   - `collection3or5`: Фильтрует элементы, кратные 3 или 5, с помощью `removeIf` и `CommonMethods.isDivisibleBy3Or5`.
   - `collectionPrime`: Фильтрует простые числа, используя `removeIf` и `CommonMethods.isPrime`.
   - `collectionAverage`: Вычисляет среднее арифметическое с использованием цикла `for`.
   - `collectionSame`: Подсчитывает частоту элементов с помощью `Collectors.groupingBy` и `Collectors.counting`, возвращая максимальную частоту.

3. **PStreamTest.java**  
   Реализует обработку коллекций типа `List<Integer>` с использованием параллельных потоков (`parallelStream`).

   - `pStream3or5`: Фильтрует элементы, кратные 3 или 5, с помощью `parallelStream` и `CommonMethods.isDivisibleBy3Or5`.
   - `pStreamPrime`: Фильтрует простые числа, используя `parallelStream` и `CommonMethods.isPrime`.
   - `pStreamAverage`: Вычисляет среднее арифметическое с помощью `mapToDouble` и `average`.
   - `pStreamSame`: Подсчитывает частоту элементов с использованием `Collectors.groupingBy` в параллельном режиме, возвращая максимальную частоту.

4. **CFTest.java**  
   Реализует асинхронную обработку коллекций типа `List<Integer>` с использованием `CompletableFuture` и пула потоков (`ExecutorService`).

   - `cf3or5`: Асинхронно фильтрует элементы, кратные 3 или 5, с помощью `CompletableFuture.supplyAsync`.
   - `cfPrime`: Асинхронно фильтрует простые числа.
   - `cfAverage`: Асинхронно вычисляет среднее арифметическое.
   - `cfSame`: Асинхронно подсчитывает максимальную частоту повторений с использованием `Collectors.groupingBy`.  
     Все методы используют фиксированный пул потоков с 8 потоками.

5. **FJTest.java**  
   Реализует параллельную обработку коллекций типа `List<Integer>` с использованием фреймворка `ForkJoinPool` и рекурсивной задачи (`RecursiveTask`).

   - `fj3or5`: Фильтрует элементы, кратные 3 или 5, с использованием рекурсивного разбиения данных.
   - `fjPrime`: Фильтрует простые числа.
   - `fjAverage`: Вычисляет среднее арифметическое, комбинируя результаты подзадач.
   - `fjSame`: Подсчитывает максимальную частоту повторений, комбинируя результаты подзадач.  
     Класс использует пороговое значение (`10_000`) для разбиения задач на подзадачи.

6. **CommonMethods.java**  
   Содержит вспомогательные методы, используемые всеми классами:

   - `isDivisibleBy3Or5`: Проверяет, кратно ли число 3 или 5.
   - `isPrime`: Проверяет, является ли число простым, с оптимизацией проверки делителей до корня числа.

7. **BenchmarkNumeric.java**  
   Класс для микробенчмаркинга с использованием JMH

   - Настраивает тесты с размером входных данных `1000000` элементов
   - Генерирует случайные массивы и коллекции (`dataArray` и `dataList`) со значениями от 1 до 1000
   - Выполняет бенчмаркинг всех методов из классов `ArrayTest`, `CollectionTest`, `PStreamTest`, `CFTest` и `FJTest`
   - Сохраняет результаты в файл `results.json` в формате JSON
   - Использует параметры JMH: 1 прогревочная итерация, 3 измеряемые итерации, режим `AverageTime`, единицы измерения — миллисекунды

8. **py.java**  
   Класс для визуализации результатов бенчмаркинга.
   - Читает данные из `benchmark-results.csv`.
   - Создаёт гистограмму с помощью JFreeChart, отображая время выполнения для каждой реализации и категории задач.
   - Группирует результаты по категориям (`3or5`, `Prime`, `Average`, `Same`) и реализациям (`Array`, `Collection`, `PStream`, `CF`, `FJ`).
   - Использует разные цвета для каждой реализации и оптимизирует отображение с помощью поворота подписей и настройки отступов.

## Требования

- **Java**: Версия 21 или выше
- **JMH**: Библиотека Java Microbenchmark Harness для измерения производительности 

## Запуск проекта
   Выполните класс BenchmarkNumeric для проведения тестов производительности
   В IntelliJIDEA должна сохраниться конфигурация запуска
   В других IDE поставьте класс для запуска
   org.openjdk.jmh.Main
   аргументы командной строки
   top.academy.BenchmarkNumeric -rf json -rff results.json -foe true

   Это создаст файл results.json с результатами тестирования.

## Визуализируйте результаты

Откройте сайт https://jmh.morethan.io/ и загрузите в него results.json

### Результаты бенчмарка

Ниже представлена таблица с результатами на 1000000 чисел (от 1 до 1000):

Benchmark                                 (size)  Mode  Cnt   Score     Error  Units
BenchmarkNumeric.averageArray            1000000  avgt    3   0,676 ±   0,670  ms/op
BenchmarkNumeric.averageCF               1000000  avgt    3   5,739 ±   4,040  ms/op
BenchmarkNumeric.averageCollection       1000000  avgt    3   2,460 ±   0,108  ms/op
BenchmarkNumeric.averageFJ               1000000  avgt    3   1,052 ±   1,211  ms/op
BenchmarkNumeric.averagePStream          1000000  avgt    3   1,128 ±   0,897  ms/op
BenchmarkNumeric.dividers3or5Array       1000000  avgt    3   6,596 ±   3,264  ms/op
BenchmarkNumeric.dividers3or5CF          1000000  avgt    3  14,755 ±  10,505  ms/op
BenchmarkNumeric.dividers3or5Collection  1000000  avgt    3  34,745 ± 193,212  ms/op
BenchmarkNumeric.dividers3or5FJ          1000000  avgt    3   9,767 ±  14,761  ms/op
BenchmarkNumeric.dividers3or5PStream     1000000  avgt    3   6,919 ±  17,310  ms/op
BenchmarkNumeric.primeArray              1000000  avgt    3  16,342 ±  26,899  ms/op
BenchmarkNumeric.primeCF                 1000000  avgt    3  18,745 ±   8,374  ms/op
BenchmarkNumeric.primeCollection         1000000  avgt    3  45,072 ± 351,787  ms/op
BenchmarkNumeric.primeFJ                 1000000  avgt    3   4,461 ±   2,687  ms/op
BenchmarkNumeric.primePStream            1000000  avgt    3   4,394 ±   3,885  ms/op
BenchmarkNumeric.sameArray               1000000  avgt    3  38,619 ±  34,245  ms/op
BenchmarkNumeric.sameCF                  1000000  avgt    3  21,212 ±  20,332  ms/op
BenchmarkNumeric.sameCollection          1000000  avgt    3  19,442 ±  31,043  ms/op
BenchmarkNumeric.sameFJ                  1000000  avgt    3   8,257 ±   1,853  ms/op
BenchmarkNumeric.samePStream             1000000  avgt    3   7,365 ±   5,293  ms/op

В виде гистограммы:

![График времени выполнения](/img/i3_10105F_(4_cores,8_logical).png)